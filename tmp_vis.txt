"""Görselleştirme ve özet istatistik yardımcıları

Bu modül, GEE `ee.Image` çıktılarından folium tabanlı haritalar üretir ve
AOI üzerinde basit özet istatistikleri (ortalama) hesaplayıp CSV’e yazar.

Best‑practice dokunuşları:
- Earth Engine tile URL alma mantığı yeni/legacy sürümlerle uyumlu.
- İsteğe bağlı açıklamalar/legend ekleyebilmek için yardımcılar mevcut.

Fonksiyonlar:
- vis_params: Harita katmanları için görselleştirme parametreleri
- save_folium: Verilen görüntüyü folium haritası olarak HTML’e kaydeder
- reduce_mean: AOI üzerinde seçili bandın ortalamasını hesaplar
- write_summary_csv: Anahtar/değer özetlerini CSV’e yazar
"""

from typing import Dict, Optional, Sequence
import os
import csv

import ee
import folium
from branca.colormap import LinearColormap

from src.utils import ensure_dir


def _center_of(aoi: ee.Geometry):
    """AOI geometrisinin merkezini (lat, lon) döndürür.

    Args:
        aoi: ee.Geometry çalışma alanı
    Returns:
        [enlem, boylam] listesi
    """
    c = aoi.centroid(10).coordinates().getInfo()
    return [c[1], c[0]]  # lat, lon


def vis_params() -> Dict[str, dict]:
    """Harita katmanları için varsayılan görselleştirme parametreleri.

    Returns:
        Her katman adı için min/max ve palette değerleri içeren sözlük.
    """
    return {
        "RGB": {"bands": ["B4", "B3", "B2"], "min": 0, "max": 3000, "gamma": [1.2, 1.2, 1.2]},
        "NDVI": {"min": -0.2, "max": 0.9, "palette": ["#440154", "#3b528b", "#21908d", "#5dc963", "#fde725"]},
        "NBR": {"min": -0.5, "max": 1.0, "palette": ["#8b0000", "#ff8c00", "#ffff00", "#00ff00", "#006400"]},
        "dNDVI": {"min": -0.6, "max": 0.6, "palette": ["#8b0000", "#ff8c00", "#ffffbf", "#a6d96a", "#1a9850"]},
        "dNBR": {"min": -0.2, "max": 1.0, "palette": ["#2b83ba", "#abdda4", "#ffffbf", "#fdae61", "#d7191c"]},
        "severity": {"min": 0, "max": 4, "palette": ["#1a9850", "#a6d96a", "#fee08b", "#f46d43", "#a50026"]},
    }


def _ee_tile_url(image: ee.Image, vis: dict) -> str:
    """GEE tile URL’sini güvenli şekilde elde et.

    Yeni sürümlerde `tile_fetcher.url_format` bulunur. Legacy’de
    `tile_url_template` ya da `mapid`/`token` ile kurulur.
    """
    info = image.getMapId(vis)
    if isinstance(info, dict):
        tf = info.get("tile_fetcher")
        if tf is not None and hasattr(tf, "url_format"):
            return tf.url_format
        if "tile_url_template" in info:
            return info["tile_url_template"]
        # Legacy explicit URL (vis mapid içinde gömülüdür; query eklemeyiz)
        if "mapid" in info and "token" in info:
            return f"https://earthengine.googleapis.com/map/{info['mapid']}/{{z}}/{{x}}/{{y}}?token={info['token']}"
    raise RuntimeError("Unable to retrieve EE tiles URL.")


def _add_ee_tile(m: folium.Map, image: ee.Image, vis: dict, name: str, opacity: float = 1.0):
    """Folium haritasına GEE görüntüsünü döşeme (tile) katmanı olarak ekler."""
    tiles_url = _ee_tile_url(image, vis)
    folium.raster_layers.TileLayer(
        tiles=tiles_url,
        attr="Google Earth Engine",
        name=name,
        overlay=True,
        control=True,
        show=True,
        opacity=opacity,
    ).add_to(m)


def _add_continuous_legend(m: folium.Map, title: str, palette: Sequence[str], vmin: float, vmax: float) -> None:
    """Sürekli renk skalası için legend (branca) ekler."""
    cmap = LinearColormap(colors=list(palette), vmin=vmin, vmax=vmax)
    cmap.caption = title
    m.add_child(cmap)


def _add_severity_legend(m: folium.Map) -> None:
    """dNBR Severity için basit ayrık legend ekler."""
    labels = ["Unburned/Low", "Low", "Moderate-Low", "Moderate-High", "High"]
    colors = ["#1a9850", "#a6d96a", "#fee08b", "#f46d43", "#a50026"]
    html = [
        '<div style="position: fixed; bottom: 25px; left: 10px; z-index: 9999; \
         background: white; padding: 10px; border: 2px solid #bbb; \
         font-size: 12px; line-height: 14px;">',
        '<b>dNBR Severity</b><br/>',
    ]
    for c, lab in zip(colors, labels):
        html.append(f'<i style="background:{c};width:12px;height:12px;display:inline-block;margin-right:6px;"></i>{lab}<br/>')
    html.append('</div>')
    folium.map.Marker(
        location=[0, 0],  # görünmez; sadece HTML eklemek için
        icon=folium.DivIcon(html=''.join(html)),
    ).add_to(m)


def save_folium(image: ee.Image, aoi: ee.Geometry, vis: dict, name: str, out_html: str):
    """GEE görüntüsünü folium haritası olarak HTML dosyasına kaydeder.

    Best‑practice eklemeler:
    - EE tile URL elde etme: yeni/legacy API uyumlu.
    - Sürekli katmanlar için otomatik legend (NDVI/NBR/d*). Severity için ayrık legend.
      (Heuristik: adı 'Severity' içerirse ayrık legend; aksi halde palette+min/max ile sürekli.)
    """
    ensure_dir(os.path.dirname(out_html))
    m = folium.Map(location=_center_of(aoi), zoom_start=9, control_scale=True)
    _add_ee_tile(m, image, vis, name)
    folium.LayerControl().add_to(m)
    try:
        if "Severity" in name:
            _add_severity_legend(m)
        elif all(k in vis for k in ("palette", "min", "max")):
            _add_continuous_legend(m, name, vis["palette"], float(vis["min"]), float(vis["max"]))
    except Exception:
        # Legend eklenemese de haritayı kaydetmeye devam et
        pass
    m.save(out_html)


def reduce_mean(image: ee.Image, aoi: ee.Geometry, band: str, scale: int = 20) -> float:
    """AOI üzerinde belirtilen bandın ortalamasını döndürür.

    Args:
        image: ee.Image
        aoi: ee.Geometry çalışma alanı
        band: Hesaplanacak band adı
        scale: Metre cinsinden çözünürlük
    Returns:
        Ortalama değer (float) veya NaN
    """
    stats = image.select(band).reduceRegion(
        reducer=ee.Reducer.mean(), geometry=aoi, scale=scale, maxPixels=1e13
    )
    val = stats.get(band).getInfo()
    return float(val) if val is not None else float("nan")


def write_summary_csv(path: str, rows: Dict[str, float]):
    """Anahtar/değer özetlerini CSV dosyasına yazar.

    Args:
        path: Çıktı CSV yolu
        rows: {metrik: değer} sözlüğü
    """
    ensure_dir(os.path.dirname(path))
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["metric", "value"])
        for k, v in rows.items():
            w.writerow([k, v])


# --- Report-friendly PNG exports ---

import requests


def _region_geojson(aoi: ee.Geometry) -> dict:
    """AOI'yi getThumbURL/getDownloadURL için GeoJSON'a dönüştürür."""
    return aoi.getInfo()


def download_png(image: ee.Image, aoi: ee.Geometry, vis: dict, out_path: str, *, scale: Optional[int] = 20, dimensions: Optional[int] = None) -> str:
    """GEE `ee.Image` için rapor dostu PNG indirir.

    image.visualize(**vis) ile 8‑bit görsel üretilir ve `getThumbURL` ile alınır.

    Args:
        image: Görselleştirilecek ee.Image
        aoi: Bölge (region)
        vis: Görselleştirme parametreleri (min/max/palette)
        out_path: Kaydedilecek PNG yolu
        scale: Piksel çözünürlüğü (metre). `dimensions` verilirse isteğe bağlıdır.
        dimensions: Uzun kenar piksel sayısı (örn. 1280). Verilirse scale yerine kullanılır.
    Returns:
        out_path
    """
    ensure_dir(os.path.dirname(out_path))
    vis_img = image.visualize(**vis)
    params: Dict[str, object] = {
        "region": _region_geojson(aoi),
        "format": "png",
    }
    if dimensions is not None:
        params["dimensions"] = dimensions
    elif scale is not None:
        params["scale"] = scale
    url = vis_img.getThumbURL(params)
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(out_path, "wb") as f:
            for chunk in r.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
    return out_path


def export_report_pngs(*, pre: ee.Image, post: ee.Image, diffs: Dict[str, ee.Image], severity: ee.Image, aoi: ee.Geometry, out_dir: str = "results") -> Dict[str, str]:
    """Pre/Post ve fark katmanlarını PNG olarak dışa aktarır.

    Üretilen dosyalar: pre_NDVI.png, post_NDVI.png, pre_NBR.png, post_NBR.png,
    dNDVI.png, dNBR.png, severity.png
    """
    ensure_dir(out_dir)
    vp = vis_params()
    outs: Dict[str, str] = {}
    outs["pre_ndvi_png"] = os.path.join(out_dir, "pre_NDVI.png")
    download_png(pre.select("NDVI"), aoi, vp["NDVI"], outs["pre_ndvi_png"], dimensions=1280)

    outs["post_ndvi_png"] = os.path.join(out_dir, "post_NDVI.png")
    download_png(post.select("NDVI"), aoi, vp["NDVI"], outs["post_ndvi_png"], dimensions=1280)

    outs["pre_nbr_png"] = os.path.join(out_dir, "pre_NBR.png")
    download_png(pre.select("NBR"), aoi, vp["NBR"], outs["pre_nbr_png"], dimensions=1280)

    outs["post_nbr_png"] = os.path.join(out_dir, "post_NBR.png")
    download_png(post.select("NBR"), aoi, vp["NBR"], outs["post_nbr_png"], dimensions=1280)

    outs["dndvi_png"] = os.path.join(out_dir, "dNDVI.png")
    download_png(diffs["dNDVI"], aoi, vp["dNDVI"], outs["dndvi_png"], dimensions=1280)

    outs["dnbr_png"] = os.path.join(out_dir, "dNBR.png")
    download_png(diffs["dNBR"], aoi, vp["dNBR"], outs["dnbr_png"], dimensions=1280)

    # Severity görseli (ayrık palet) için de visualize kullanılabilir
    outs["severity_png"] = os.path.join(out_dir, "severity.png")
    download_png(severity, aoi, vp["severity"], outs["severity_png"], dimensions=1280)
    return outs


def export_truecolor_pngs(
    *,
    pre: ee.Image,
    post: ee.Image,
    aoi: ee.Geometry,
    out_dir: str = "results",
    min_val: int = 0,
    max_val: int = 3000,
    gamma: float = 1.2,
) -> Dict[str, str]:
    """Sentinel‑2 doğal renk (B4,B3,B2) PNG çıktıları üretir (rapor dostu).

    Args:
        pre: Ön dönem kompozit görüntü (orijinal bantları içermeli)
        post: Sonraki dönem kompozit görüntü
        aoi: Bölge
        out_dir: Çıktı klasörü
        min_val, max_val: Görselleştirme aralığı (S2 SR için genelde 0–3000 iyi başlangaç)
        gamma: Gamma düzeltmesi (RGB için 1.1–1.4 arası önerilir)
    Returns:
        {anahtar: yol} sözlüğü (pre_rgb_png, post_rgb_png)
    """
    ensure_dir(out_dir)
    vis_rgb = {"bands": ["B4", "B3", "B2"], "min": min_val, "max": max_val, "gamma": [gamma, gamma, gamma]}
    outs: Dict[str, str] = {}
    outs["pre_rgb_png"] = os.path.join(out_dir, "pre_RGB.png")
    download_png(pre, aoi, vis_rgb, outs["pre_rgb_png"], dimensions=1600)
    outs["post_rgb_png"] = os.path.join(out_dir, "post_RGB.png")
    download_png(post, aoi, vis_rgb, outs["post_rgb_png"], dimensions=1600)
    return outs


def compute_severity_areas(severity: ee.Image, aoi: ee.Geometry, *, scale: int = 10) -> Dict[str, float]:
    """dNBR şiddet sınıfları için alan (m^2 ve ha) ve toplam yanmış alanı hesaplar.

    Sınıf kodları 0..4; yanmış alan = kod >= 1 sınıfların toplamı.
    """
    # AOI alanı (m^2)
    aoi_area_stats = ee.Image.pixelArea().reduceRegion(
        reducer=ee.Reducer.sum(), geometry=aoi, scale=scale, maxPixels=1e13
    )
    aoi_area_m2_val = aoi_area_stats.get('area').getInfo()
    aoi_area_m2 = float(aoi_area_m2_val) if aoi_area_m2_val is not None else 0.0
    results: Dict[str, float] = {
        'aoi_area_m2': aoi_area_m2,
        'aoi_area_ha': aoi_area_m2 / 1e4,
    }
    burned_m2 = 0.0
    for code in range(5):
        stats = ee.Image.pixelArea().updateMask(severity.eq(code)).reduceRegion(
            reducer=ee.Reducer.sum(), geometry=aoi, scale=scale, maxPixels=1e13
        )
        area_val = stats.get('area').getInfo()
        m2 = float(area_val) if area_val is not None else 0.0
        results[f'class_{code}_m2'] = m2
        results[f'class_{code}_ha'] = m2 / 1e4
        if code >= 1:
            burned_m2 += m2
    results['burned_area_m2'] = burned_m2
    results['burned_area_ha'] = burned_m2 / 1e4
    return results


def write_kv_csv(path: str, rows: Dict[str, float]) -> None:
    """metric,value biçiminde CSV yazar."""
    ensure_dir(os.path.dirname(path))
    with open(path, 'w', newline='', encoding='utf-8') as f:
        w = csv.writer(f)
        w.writerow(['metric', 'value'])
        for k, v in rows.items():
            w.writerow([k, v])

